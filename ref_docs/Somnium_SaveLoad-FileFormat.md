# Save/Load File Format Specification

The save/load system in Somnium is designed to capture the entire state of an adventure in a single file, enabling players to pause their unique story and resume it later exactly as they left it. This specification details the structure of the save file, which is a JSON format for simplicity and transparency.

## Overview

**File Type:** JSON (text).
**Extension:** `.somnium.json` (or simply `.json` – we might use a custom extension to distinguish saves, e.g., `.somsave`).
**Encoding:** UTF-8.

By using JSON, we make it easy for developers to parse and debug save files. The downside is slightly larger file size and the possibility of user tampering, but given single-player nature, that’s acceptable. We also include a version number so we can maintain compatibility as the game evolves.

A save file consists of two main parts:

* **Resources**: The original generated content of the game (the world description JSON from the LLM).
* **State**: The dynamic state info that has changed since the start (or was established at start, like initial flags and player position).

## Save File Structure

Top-level JSON structure:

```json
{
  "version": 1,
  "resources": { ... },
  "state": { ... }
}
```

* **version** (number): The version of the save format. Starts at 1. If we change the format in the future (add/remove fields), we'll increment this. The loader will check this to apply any conversions or compatibility fixes.

* **resources** (object): This is essentially the exact JSON that was generated by the LLM at game start, containing the plot, rooms, items, puzzles, etc. It’s the entire static content of the game world. We store it so that upon loading, we don’t need to regenerate or query the AI; we can rebuild the world from this.

  * It includes keys like "plot", "rooms", "items", "puzzles", and possibly "objects" or others as described in LLM Interaction spec.
  * This portion should be identical to what one would get by stringifying the game data at the moment after generation. We do not modify it during play except perhaps adding in `objects` if the initial format didn’t have a separate list (some objects might be only in rooms, but we might keep them separate for ease).

* **state** (object): This captures everything that can change during gameplay. Key subfields might include:

  * `currentRoom` (string): The ID of the room the player is currently in.
  * `inventory` (array of strings): List of item IDs that the player currently carries.
  * `visitedRooms` (array of strings, optional): We might track which rooms have been visited (could be used for something like not repeating certain text or achievements).
  * `flags` (object): A dictionary of global flags or variables (usually boolean values or small numbers) that have been set. For example, `{"dragon_defeated": true, "password_found": true}`.
  * `objectStates` (object): State of objects and NPCs:

    * This could include location changes, visibility, custom properties changed. For instance, if an object was originally in room A but moved to room B (or inventory), we'd reflect that.
    * If an object’s description or events have been altered (some games dynamically change descriptions after an event), we might store those as well, although we often can derive it from flags. But to be safe, if the LLM generated complex objects, we capture essential changes.
    * Could be structured as:

      ```json
      "objectStates": {
         "oak_door": { "open": true, "locked": false },
         "troll": { "alive": false }
      }
      ```

      The keys are object IDs, values are object-specific state. Alternatively, we incorporate such into flags or the `objects` resource themselves.
    * Also includes NPC positions if they move.
  * `roomsState` (object): Similar concept but per room, if any room-specific state beyond objects:

    * e.g., which exits are open/closed if that’s dynamic. Could be under flags too, but we may mirror it here for clarity.
    * Possibly a list of items currently in each room (but we can derive that: items that are not in inventory and have an `initialRoom` could be considered still there unless flagged taken).
  * `timers` (array): If there are active timed events in queue, we save enough info to restart them correctly. For example, if a 60-second timer was halfway when saved, we store remaining 30s so it can resume.

    * If complexity is high, we might simply not store mid-countdown timers; instead, maybe cancel or reset them on load. But for perfect fidelity, storing them is ideal.
  * `score` (number, optional): If we implement a score system, save current points.
  * `moves` or `timePlayed`: Some games track turns or time elapsed. We can store it for reference or score calculation.
  * `viewStates` (object): The position and animation state of all active view objects (player and NPC sprites).

    * e.g.,

      ```json
      "viewStates": {
         "player": { "room": "hallway", "x": 100, "y": 120, "loop": "idle", "frame": 0 },
         "guard": { "room": "dungeon", "x": 50, "y": 130, "loop": "sleeping", "frame": 2 }
      }
      ```

      This ensures when we load, we draw sprites in the exact spots and frames they were. Without this, they'd reset to defaults (like NPC at start position). Usually that's fine, but to be precise we save it.
    * If an NPC was removed (like killed), we either don't include it or mark it in state so engine knows not to draw it (even though resources might still have it).
  * `randomSeeds` (object, optional): If any randomness was used (like for music generation or if the AI gave a range and we picked a random one), store the seeds so that on reload the procedural aspects (like a tone sequence) are reproducible. For example, Tone.js might have random music; if we want the same melody post-load, we need to have seeded that generator the same way.

This structure covers pretty much everything. Essentially, if it's not in `state`, it’s assumed to be as per `resources` default. That means we don't duplicate static info (like unchanged room descriptions) in state. The engine on load will merge the two:

* Load resources into GameState (so we have baseline).
* Then apply state deltas (moving items, flags, etc.) to reach the saved state.

## Example Save File

Here is a simplified example to illustrate (assuming a scenario mid-game):

```json
{
  "version": 1,
  "resources": {
    "plot": {
      "title": "Mystery of the Lost City",
      "backstory": "You are an explorer in search of a legendary lost city in the jungle...",
      "goal": "Find the lost city and uncover its treasure."
    },
    "items": [
      { "id": "ancient_map", "name": "an ancient map", "description": "A map showing the way through the jungle." },
      { "id": "machete", "name": "a machete", "description": "Useful for cutting through dense foliage." },
      { "id": "gem", "name": "a strange gem", "description": "A gem emitting a faint glow." }
    ],
    "puzzles": [
      {
        "id": "blocked_path",
        "obstacle": "A dense wall of vines blocks the path.",
        "solution": { "verb": "use", "item": "machete", "target": "vines" },
        "reward_text": "You hack away the vines with the machete, clearing the path.",
        "unlocks": { "type": "ENABLE_EXIT", "roomId": "jungle_depths", "exit": "north" }
      }
    ],
    "rooms": [
      {
        "id": "camp",
        "name": "Base Camp",
        "description": "Tents and equipment are scattered around your base camp at the jungle's edge.",
        "exits": { "north": "jungle_entrance" },
        "items": [ "machete" ],
        "objects": [],
        "sound": { "music_theme": "an adventurous theme with percussion", "ambience": "night insects chirping" },
        "graphics": { ... }
      },
      {
        "id": "jungle_entrance",
        "name": "Jungle Entrance",
        "description": "Towering trees and thick undergrowth welcome you into the jungle. There's a path leading north, overgrown with vines.",
        "exits": { "south": "camp", "north": "jungle_depths" },
        "items": [ "ancient_map" ],
        "objects": [ "vines" ],
        "sound": { "music_theme": "a tense, rhythmic jungle tune", "ambience": "distant animal calls" },
        "graphics": { ... }
      },
      {
        "id": "jungle_depths",
        "name": "Deep Jungle",
        "description": "Sunlight barely pierces the canopy here. An ancient stone gate is visible to the north.",
        "exits": { "south": "jungle_entrance", "north": "lost_city_gate" },
        "items": [ "gem" ],
        "objects": [ "stone_gate" ],
        "sound": { "music_theme": "mysterious humming", "ambience": "wind rustling leaves" },
        "graphics": { ... }
      },
      ...
    ],
    "objects": [
      { "id": "vines", "name": "thick vines", "description": "They block the northern path.",
        "events": {
          "onLook": { "responseText": "The vines are thick and tangled." },
          "onUse": {
            "condition": "player.hasItem('machete')",
            "responseText": "You hack at the vines with the machete.",
            "actions": [
              { "type": "SET_FLAG", "name": "vines_cleared", "value": true }
            ]
          },
          "onUse_fallback": { "responseText": "You try to pull the vines apart, but they're too thick." }
        }
      },
      { "id": "stone_gate", "name": "stone gate", "description": "An ancient stone gate with strange inscriptions. It seems to require a gem.",
        "events": { ... }
      }
    ]
  },
  "state": {
    "currentRoom": "jungle_entrance",
    "inventory": [ "ancient_map", "machete" ],
    "flags": { "vines_cleared": true },
    "objectStates": {
      "vines": { "description": "The cut vines lie on the ground, path is clear." }
    },
    "viewStates": {
      "player": { "room": "jungle_entrance", "x": 160, "y": 180, "loop": "idle", "frame": 0 }
    },
    "timers": [],
    "score": 5,
    "moves": 20
  }
}
```

In this example:

* The `resources` define the initial game world (camp, vines puzzle, etc.).
* The `state` reflects that:

  * The player is in "jungle\_entrance".
  * The player has the map and machete in inventory (perhaps picked up from camp).
  * The vines\_cleared flag is true (meaning the puzzle was solved, presumably unlocking the path north).
  * We even updated the vines object description to reflect it's cut (optional, but nice for consistency).
  * `viewStates` shows the player's position in the jungle entrance (x=160, y=180 coordinates).
  * Score and moves indicate the player has done some actions.

When loading this:

* The engine reads version (1, no special handling needed).
* Loads all `resources`: so it now knows the world as at start (with vines, etc.).
* Then applies `state`: sets current room, moves the machete and map to inventory (so likely it will remove them from the room's items list internally), sets the vines\_cleared flag (so any conditions depending on that will be true, and maybe event manager will treat vines as cleared).
* It may also adjust the world based on flags: e.g., if vines\_cleared is true, maybe the engine should disable the vines object or mark the north exit as enabled (since puzzle said it unlocks).

  * Actually, we might not need to explicitly store that "north exit enabled" because the script action or puzzle unlock defines it. But to be safe, one could store that as well: maybe in objectStates or flags.
  * In this example, we didn't explicitly store exit state because we assume the engine, seeing vines\_cleared, will allow going north (maybe via script or because we might modify the exits at runtime).
* Continue applying state: update any object descriptions or removal (the vines description changed).
* Place the player sprite at given position.

Everything needed to resume is there. The player will see the vines already cut and can go north immediately.

## Loading Mechanism

When the user chooses to load a file:

* We parse the JSON (with error handling).
* Check `version`:

  * If higher than our engine supports, warn the user or attempt compatibility. If lower, maybe we adapt (for example, if version 2 had an extra field, version 1 missing it, we can set default).
  * For now, just ensure it's 1.
* We reconstruct the `GameState`:

  * The engine likely has a method like `GameState.load(resources)` which sets up all rooms, items, etc., like starting a new game but from provided data instead of AI.
  * Then a method `GameState.applyState(state)` to apply the dynamic changes.
* Then we set the current room and render it. Because we saved view coordinates, we place the player at correct spot.
* Resume any timers: e.g., if an event was scheduled 5s later at save time, we reschedule it for 5s from now.
* Music and sound: We likely restart the current room's music. If a special event music was playing at save, we might not track that, but usually music ties to room. If we needed, we could store currently playing track/time. But we can simplify: just start the room's theme fresh.
* After loading, the game should behave identical to if it had never been closed:

  * All flags and conditions in place.
  * All objects in correct state (e.g., vines cut).
  * If mid-dialog or mid-combat we didn't handle explicitly, those likely reset to a safe state (some things can't resume exactly if not stored, but we design around needing that).
  * The player can continue playing from that point.

## Compatibility and Security

* Save files are JSON, so a user can edit them. This can be considered a feature (some like to cheat or mod). It’s single-player, so no harm. But we should:

  * Validate the data when loading: e.g., if an ID in inventory doesn’t exist, ignore it or warn. If a flag in state wasn’t in original resources, it’s okay (engine can handle unknown flags, they just might not affect anything).
  * If something crucial is missing or file malformed, handle gracefully (error message "Save file corrupted or incompatible.").

* We should also be careful about code injection: JSON is just data, but if someone put a `<script>` tag in a description? When we display that description in HTML, we should be escaping it anyway. We likely display text in text nodes (not raw HTML) to avoid any injection issues. So even if save file (or LLM output) contained something like `<img src=x onerror=alert(1)>`, it wouldn’t execute if we handle text properly.

* We could in theory compress the JSON (zip) to reduce file size and also deter casual editing, but it's not necessary and being plain text has benefits (portability, transparency).

* Backwards compatibility: if in future we add a field, older saves won't have it, so we ensure engine gives default. For example, if v2 added `playerStats`, then loading a v1 save just means no `playerStats`, we initialize with defaults (like stat values at creation or zeros).

  * If an old save missing something critical for new logic, maybe not fully compatible, but we try to at least not break.

* Forward compatibility (loading a newer save with older engine) is generally not supported; we’d tell user to upgrade the game if that happens (or we can’t parse unknown fields).

* We include version specifically for such cases.

## Save/Load UI and Process

While not exactly format spec, some notes:

* The "Save Game" function triggers a JSON export (maybe using `URL.createObjectURL` to let user download). We might prompt for filename or use a default like `Somnium_Save_<gametitle>_<timestamp>.somnium.json`.
* The "Load Game" function will let user pick a file (input type file). We parse it and call our load logic.
* We should handle errors gracefully:

  * If the JSON parse fails (maybe user selected a wrong file), show "Invalid save file."
  * If version incompatible, show message.
* Possibly disable load if a game is running and unsaved changes exist (or allow and just override).
* We cannot merge saves (only one at a time to load).
* Also note: Because each generated game is unique, a save file from one adventure is not applicable to another. It's self-contained with its content. So "Loading" always includes content. That means if the user generated a world, didn't save it, then later tries to load a save from a different time, it will replace everything (which is correct).
* The system is robust in that regard: you can share a save file and someone else could load it to play that specific adventure.

## Efficiency

Saving everything including resources duplicates data that is static. That’s fine given size (some tens of KB, maybe 100KB if large).

* We could optimize by only saving state and requiring re-generation for resources (like seed-based regen). But that’s unreliable since LLM might not generate exactly the same again without a fixed seed and deterministic model (which we don't have). So storing resources is safer.
* If we worry about file size, compressing JSON to a binary would be next step, but likely unnecessary for these scales.

## Future Considerations

* If we implement a cloud save or persistent browser storage, we'd use the same JSON format but store it in IndexedDB or localStorage (if small enough).
* The spec is easy to extend: you can add new keys under state without breaking older loads because the loader can ignore unknown fields if coded to do so.
* For example, if later we add `achievements` or something, adding to state is fine.
* If we add `dialogs` or `journal` that tracks clues, could save that too in state.

In summary, the save file format is straightforward JSON, aiming to ensure **complete restoration** of the game state. By following this spec, any developer or tool can parse or even modify Somnium save files. But importantly, our engine will rely on this structure to load games reliably, so consistency is key.
