---
applyTo: '**/*'
---

# GitHub Copilot Instructions for Somnium

This repository contains Somnium, an AI-driven graphical text-adventure game inspired by Sierra On-Line's SCI0-era games (1988-1989). The project generates unique adventures at runtime using LLMs while maintaining strict adherence to retro aesthetics and technical constraints.

## Project Overview

Somnium follows Sierra's SCI philosophy of complete separation between engine and content:

- **Engine**: JavaScript modules that interpret game data (analogous to SCI interpreter)
- **Content**: AI-generated JSON packages containing all game resources (analogous to compiled SCI resources)

## Core Architecture

The project is organized into phases, with Phases 1-3 complete:

### Phase 1 - Core Architecture ✅

- **GameManager.js**: Main game loop with fixed timestep (60 FPS), FPS monitoring, pause/resume
- **AIManager.js**: LLM communication with mock mode for testing, rate limiting, caching
- **GameState.js**: Event-driven state management with validation, history, and undo
- **EventManager.js**: Event system with scripted/dynamic responses and scheduling

### Phase 2 - Graphics and Sound ✅

- **SceneRenderer.js**: Complete vector rendering with EGA palette, 9 dithering patterns, priority buffer
- **ViewManager.js**: Full sprite animation with VIEW resources, smooth interpolation, effects
- **SoundManager.js**: Tone.js integration with ADSR envelopes, filters, effects, 16 channels

### Phase 3 - Parser and Game Logic ✅

- **Parser.js**: Natural language parser with tokenization, synonyms, abbreviations, pronouns
- **CommandExecutor.js**: Handles 30+ adventure game verbs with contextual responses
- **Inventory.js**: Enhanced inventory with weight/size limits, containers, worn items
- **InteractionSystem.js**: Object interaction matrix for "use X on Y" mechanics
- **MovementSystem.js**: Advanced movement with pathfinding and animations
- **PuzzleSystem.js**: Multi-step puzzles with state tracking and hint system
- **NPCSystem.js**: Dialogue trees, trading, and relationship tracking
- **GameProgression.js**: Scoring, achievements, and multiple endings

## Technical Constraints (CRITICAL)

These constraints MUST be respected in all code changes:

1. **Graphics**: Strict 320×200 resolution, 16-color EGA palette ONLY
   - No modern image formats (PNG, JPG, SVG files)
   - All graphics must be vector primitives (rectangles, polygons, dithered gradients)
2. **Sound**: Procedural generation via Tone.js descriptors ONLY
   - No audio files (MP3, WAV, OGG)
   - All sound effects and music must be generated from descriptors
3. **Parser**: Must handle Sierra-style abbreviations and synonyms
   - Support multi-word commands and natural language
   - Maintain compatibility with classic adventure game syntax
4. **Save Format**: Complete game state + original AI-generated JSON in single file
   - Must preserve entire playthrough state for restoration

5. **Browser Compatibility**: Support Chrome 80+, Firefox 75+, Safari 13+, Edge 80+
   - Test across multiple browsers
   - Use Web Audio API and Canvas correctly

## Development Workflow

### Required Commands

```bash
# Install dependencies (use npm ci for clean install)
npm ci

# Local development server (REQUIRED - CORS restriction for ES modules)
npm start    # Port 8080
npm run dev  # Port 8000

# Testing (Jest 30 requires Node.js 18+)
npm test              # Run all tests
npm run test:watch    # Watch mode
npm run test:coverage # Generate coverage report

# Code Quality (MUST pass before PR merge)
npm run lint          # Run ESLint
npm run lint:fix      # Auto-fix ESLint issues
npm run format        # Format with Prettier
npm run format:check  # Check formatting
npm run validate      # Run all checks (format + lint + test)
```

### Before Making Changes

1. **Always run tests first** to understand current state: `npm test`
2. **Check lint status**: `npm run lint`
3. **Review CLAUDE.md** for detailed module information
4. **Understand the retro gaming context** - this is NOT a modern web game

### After Making Changes

1. **Run tests**: `npm test` (444 tests must pass)
2. **Run linting**: `npm run lint:fix`
3. **Format code**: `npm run format`
4. **Validate everything**: `npm run validate`

## Coding Standards

### File Organization

- All game engine code in `/js/` directory
- Tests in `/tests/` directory (Jest with jsdom)
- Demos in `/demos/` directory
- Documentation in `/docs/` and `/ref_docs/`

### Code Style

- **ES Modules**: Always use `export` and `import`, never CommonJS
- **Modern JavaScript**: ES2021+ syntax (arrow functions, async/await, etc.)
- **No inline console**: Use the Logger module (js/logger.js)
- **Event-driven**: Use EventTarget for loose coupling between modules
- **Validation**: All game data must be validated on load
- **Mock modes**: All modules should support mock/test mode

### Naming Conventions

- **Files**: PascalCase for modules (e.g., `GameManager.js`)
- **Classes**: PascalCase (e.g., `class GameManager`)
- **Functions**: camelCase (e.g., `function executeCommand()`)
- **Constants**: UPPER_SNAKE_CASE (e.g., `const API_CONFIG`)
- **Private methods**: Prefix with `_` (e.g., `_validateState()`)

## Testing Requirements

### Test Coverage

Current status: 444 tests passing (100% pass rate), 61.64% overall coverage

High coverage areas:

- Parser: 87.37%
- NPCSystem: 81.19%
- InteractionSystem: 79.87%
- PuzzleSystem: 71.42%

### Test Focus Areas

1. **Parser Coverage**: Verb synonyms, abbreviations, pronouns
2. **State Consistency**: Save/load preservation, puzzle state tracking
3. **Graphics Rendering**: Primitive layering, z-order, EGA color accuracy
4. **AI Responses**: Validate JSON structure, handle malformed responses
5. **Cross-browser**: Canvas rendering, Web Audio API compatibility

### Writing Tests

- Use Jest with jsdom environment
- Mock external dependencies (Tone.js, Canvas API)
- Test both success and error paths
- Include edge cases and boundary conditions
- Follow existing test patterns in `/tests/` directory

## AI Integration Guidelines

### World Generation

- Single master JSON request at game start containing ALL resources
- Validate all object/item/room ID references for consistency
- Ensure every puzzle has obtainable solution items
- Maintain family-friendly content (built-in moderation)

### Dynamic Interactions

- Scripted events take precedence over LLM responses
- Context must include: current room, visible objects, recent events, inventory
- LLM fallback for unscripted actions must NOT break game logic
- Rate limit API calls to avoid overwhelming the service

## Common Tasks

### Adding a New Game Feature

1. Check if feature fits SCI0 constraints (no modern graphics/audio)
2. Design using existing module patterns (EventTarget, mock mode)
3. Write tests first (TDD approach)
4. Implement in appropriate module(s)
5. Update relevant demo if applicable
6. Document in appropriate `/docs/` file
7. Run full validation: `npm run validate`

### Fixing a Bug

1. Write a failing test that reproduces the bug
2. Fix the bug with minimal changes
3. Verify test now passes
4. Check no other tests broke
5. Run full validation: `npm run validate`

### Updating Dependencies

- Use `npm ci` for clean installs
- Test thoroughly after updates
- Check browser compatibility
- Update package.json and package-lock.json together
- Never commit `node_modules/` directory

## Important Notes

### What NOT to Do

- ❌ Do NOT add raster images (PNG, JPG, SVG files)
- ❌ Do NOT add audio files (MP3, WAV, OGG)
- ❌ Do NOT modify the EGA palette (16 colors only)
- ❌ Do NOT change resolution from 320×200
- ❌ Do NOT commit API keys or secrets
- ❌ Do NOT remove or modify working tests
- ❌ Do NOT break backward compatibility with save files

### Security

- API keys must be in `js/config.js` (gitignored)
- Never commit secrets to repository
- Use mock mode for testing without API access
- Validate all AI-generated content
- Implement content moderation for family-friendly experience

## CI/CD

GitHub Actions CI runs on:

- Node.js versions: 18.x and 20.x
- Jobs: Lint, Test (with coverage), Security Audit, Browser Compatibility
- All checks must pass before merging PRs
- Coverage reports uploaded to Codecov

## Documentation

### Key Files to Reference

- **CLAUDE.md**: Detailed module information and implementation notes
- **README.md**: User-facing documentation and quick start
- **CONTRIBUTING.md**: Contribution guidelines
- **docs/architecture-overview.md**: System design details
- **ref_docs/**: Comprehensive design specifications

### Demo Pages

All demos in `/demos/` subdirectory:

- `demo-graphics.html` - Vector primitives and EGA palette
- `sprite-demo.html` - Character movement with keyboard
- `sound-demo.html` - Sound effect library
- `music-demo.html` - Real-time music generation
- `parser-demo.html` - Natural language parser
- `game-world-demo.html` - Puzzle and NPC systems
- `demo-adventure.html` - Complete playable adventure

## Getting Help

- Review existing code in `/js/` for patterns
- Check test files in `/tests/` for examples
- Read design documents in `/ref_docs/`
- Look at demo implementations in `/demos/`
- Consult CLAUDE.md for detailed guidance

## Summary

When working on Somnium:

1. **Respect retro constraints** - EGA graphics, procedural sound, 320×200 resolution
2. **Run tests early and often** - 444 tests must stay passing
3. **Follow existing patterns** - Event-driven, ES modules, mock modes
4. **Validate everything** - Linting, formatting, testing before PR
5. **Think like Sierra** - SCIO engine philosophy guides all design decisions

The goal is authentic 1988-1989 era adventure gaming with modern AI-driven content generation. Every feature should honor that vision.
